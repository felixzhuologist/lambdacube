use assoclist::{AssocList};
use ast::{ArithOp, BoolOp, Term};

use std::str::FromStr;

grammar;

pub Expr: Box<Term> = {
    <Term>,
    "not" <Expr> => Box::new(Term::Not(<>)),
    "if" <Expr> "then" <Expr> "else" <Expr> => Box::new(Term::If(<>)),
    "let" <Ident> ":=" <Expr> => Box::new(Term::Let(<>)),
    FuncDef <Ident> "." <Expr> => Box::new(Term::Abs(<>)),
    Term ArithOp Expr => Box::new(Term::Arith(<>)),
    Term BoolOp Expr => Box::new(Term::Logic(<>)),
}

Term: Box<Term> = {
    <ATerm>,
    Term ATerm => Box::new(Term::App(<>)),
    Term FactorOp ATerm => Box::new(Term::Arith(<>)),
}

ATerm: Box<Term> = {
    Ident => Box::new(Term::Var(<>)),
    Num => Box::new(Term::Int(<>)),
    Bool => Box::new(Term::Bool(<>)),
    "(" <Expr> ")",
    "{" <CommaSep<RecordField>> "}" =>
        Box::new(Term::Record(AssocList::from_vec(<>))),
}

RecordField: (String, Box<Term>) = {
    <Ident> ":" <Expr> => (<>)
}

CommaSep<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(field) => {
            let mut v = v;
            v.push(field);
            v
        }
    }
}

Ident: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string()
}

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
}

Bool: bool = {
    "true" => true,
    "false" => false,
}

ArithOp: ArithOp = {
    "+" => ArithOp::Add,
    "-" => ArithOp::Sub,
    "%" => ArithOp::Mod,
    "=" => ArithOp::Eq_,
    "/=" => ArithOp::Neq,
    ">" => ArithOp::Gt,
    "<" => ArithOp::Lt,
    ">=" => ArithOp::Gte,
    "<=" => ArithOp::Lte,
}

FactorOp: ArithOp = {
    "*" => ArithOp::Mul,
    "/" => ArithOp::Div,
}

BoolOp: BoolOp = {
    "and" => BoolOp::And,
    "or" => BoolOp::Or,
}

FuncDef = {
    "lambda",
    "Î»",
    "fun"
}
