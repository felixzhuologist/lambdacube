use assoclist::{AssocList};
use syntax::{ArithOp, BoolOp, Term, Type, Command, Binder};

use std::str::FromStr;

grammar;

pub Toplevel: Vec<Command> = {
    <(<Command> ";")+>
}

pub Command: Command = {
    <Binder> => Command::Binder(<>),
    <Term> => Command::Term(<>),
}

pub Binder: Binder = {
    "let" <s:Ident> "=" <t:Term> => Binder::VarBind(s, *t),
    "type" <s:TyIdent> "=" <t:Type> => Binder::TyBind(s, *t),
}

pub Term: Box<Term> = {
    <AppTerm>,
    "not" <Term> => Box::new(Term::Not(<>)),
    "if" <Term> "then" <Term> "else" <Term> => Box::new(Term::If(<>)),
    "let" <Ident> "=" <Term> "in" <Term> => Box::new(Term::Let(<>)),
    FuncDef <Ident> ":" <Type> "." <Term> => Box::new(Term::Abs(<>)),
    FuncDef <Ident> "." <Term> => Box::new(Term::InfAbs(<>)),
    AppTerm ArithOp Term => Box::new(Term::Arith(<>)),
    AppTerm BoolOp Term => Box::new(Term::Logic(<>)),
}

AppTerm: Box<Term> = {
    <PathTerm>,
    AppTerm PathTerm => Box::new(Term::App(<>)),
    AppTerm FactorOp PathTerm => Box::new(Term::Arith(<>)),
}

PathTerm: Box<Term> = {
    <PathTerm> "." <Ident> => Box::new(Term::Proj(<>)),
    <PathTerm> "." <Ident> "<-" <ATerm> => Box::new(Term::SetProj(<>)),
    <ATerm>,
}

ATerm: Box<Term> = {
    "()" => Box::new(Term::Unit),
    Ident => Box::new(Term::Var(<>)),
    Num => Box::new(Term::Int(<>)),
    Bool => Box::new(Term::Bool(<>)),
    "(" <TermSeq> ")",
    "{" <CommaSep<RecordField>> "}" =>
        Box::new(Term::Record(AssocList::from_vec(<>))),
}

TermSeq: Box<Term> = {
    <Term>,
    <t1:Term> ";" <t2:TermSeq> => {
        let func = Term::Abs(String::from("_"), Box::new(Type::Unit), t2);
        Box::new(Term::App(Box::new(func), t1))
    }
}

RecordField: (String, Box<Term>) = {
    <Ident> "=" <Term> => (<>)
}

TyIdent: String = {
    r"[A-Z][a-zA-Z0-9_]*" => <>.to_string()
}

Ident: String = {
    r"[a-z_][a-zA-Z0-9_]*" => <>.to_string()
}

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
}

Bool: bool = {
    "true" => true,
    "false" => false,
}

ArithOp: ArithOp = {
    "+" => ArithOp::Add,
    "-" => ArithOp::Sub,
    "%" => ArithOp::Mod,
    "==" => ArithOp::Eq_,
    "!=" => ArithOp::Neq,
    ">" => ArithOp::Gt,
    "<" => ArithOp::Lt,
    ">=" => ArithOp::Gte,
    "<=" => ArithOp::Lte,
}

FactorOp: ArithOp = {
    "*" => ArithOp::Mul,
    "/" => ArithOp::Div,
}

BoolOp: BoolOp = {
    "and" => BoolOp::And,
    "or" => BoolOp::Or,
}

FuncDef = {
    "lambda",
    "Î»",
    "fun"
}

pub Type: Box<Type> = {
    <AType>,
    <AType> "->" <Type> => Box::new(Type::Arr(<>)),
}

AType: Box<Type> = {
    "(" <Type> ")",
    "{" <CommaSep<RecordFieldType>> "}" =>
        Box::new(Type::Record(AssocList::from_vec(<>))),
    "Bool" => Box::new(Type::Bool),
    "Int" => Box::new(Type::Int),
    <TyIdent> => Box::new(Type::Var(<>)),
}

RecordFieldType: (String, Box<Type>) = {
    <Ident> ":" <Type> => (<>)
}

CommaSep<T>: Vec<T> = {
    // lalrpop macro syntax:
    // v matches a * amount of "T," and return Vec<T>
    // e possibly matches a T, returning an Option<T>
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(field) => {
            let mut v = v;
            v.push(field);
            v
        }
    }
}
