use assoclist::{AssocList};
use syntax::{ArithOp, BoolOp, Term, Type, Kind, Command, Binder};

use std::str::FromStr;

grammar;

pub Toplevel: Vec<Command> = {
    <(<Command> ";")+>
}

pub Command: Command = {
    <Binder> => Command::Binder(<>),
    <Term> => Command::Term(<>),
}

pub Binder: Binder = {
    "let" <s:Ident> "=" <t:Term> => Binder::VarBind(s, *t),
    "let" <s:Ident> <p:Params> "=" <t:Term> => {
        let func = p.into_iter().rev().fold(*t, |func, next_param| match next_param {
            (arg, Some(ty)) => Term::Abs(arg, ty, Box::new(func)),
            (arg, None) => Term::InfAbs(arg, Box::new(func))
        });
        Binder::VarBind(s, func)
    },
    "open" <mod_:Term> "as" <v:Ident> ":" <tyv:TyIdent> =>
        Binder::ModuleBind(v, tyv, *mod_),
    "type" <s:TyIdent> "=" <t:Type> => Binder::TyBind(s, *t),
}

// TODO: let users evaluate global type binders to have the type printed out?
pub Term: Box<Term> = {
    <AppTerm>,
    "not" <Term> => Box::new(Term::Not(<>)),
    "if" <Term> "then" <Term> "else" <Term> => Box::new(Term::If(<>)),
    "let" <Ident> "=" <Term> "in" <Term> => Box::new(Term::Let(<>)),
    "open" <mod_:Term> "as" <v:Ident> ":" <tyv:TyIdent> "in" <term:Term> =>
        Box::new(Term::Unpack(tyv, v, mod_, term)),
    FuncDef <p:Params> "->" <t:Term> => 
        Box::new(p.into_iter().rev().fold(*t, |func, next_param| match next_param {
            (arg, Some(ty)) => Term::Abs(arg, ty, Box::new(func)),
            (arg, None) => Term::InfAbs(arg, Box::new(func))
        })),
    FuncDef "[" <univ:NECommaSep<TypeParam>> "]" <p:TypedParams> "->" <body:Term> => {
        let func = p
            .into_iter()
            .rev()
            .fold(*body, |func, (arg, ty)| Term::Abs(arg, ty, Box::new(func)));

        Box::new(univ
            .into_iter()
            .rev()
            .fold(func, |func, next_| match next_ {
                (var, Some(bound)) => Term::BoundedTyAbs(var, Box::new(func), bound),
                (var, None) => Term::TyAbs(var, Box::new(func)),
            }))
    },
    AppTerm ArithOp Term => Box::new(Term::Arith(<>)),
    AppTerm BoolOp Term => Box::new(Term::Logic(<>)),
}

TypeParam: (String, Option<Box<Type>>) = {
    <TyIdent> <("<:" <Type>)?>
}

TypedParams: Vec<(String, Box<Type>)> = {
    ("(" <Ident> ":" <Type> ")")+
}

Params: Vec<(String, Option<Box<Type>>)> = {
    (<Param>)+
}

Param: (String, Option<Box<Type>>) = {
    <Ident> => (<>, None),
    "(" <s:Ident> ":" <t:Type> ")" => (s, Some(t))
}

AppTerm: Box<Term> = {
    <PathTerm>,
    AppTerm PathTerm => Box::new(Term::App(<>)),
    <univ:AppTerm> "[" <tys:NECommaSep<Type>> "]" => 
        Box::new(tys
            .into_iter()
            .rev()
            .fold(*univ, |acc, ty| Term::TyApp(Box::new(acc), ty))),
    AppTerm FactorOp PathTerm => Box::new(Term::Arith(<>)),
}

PathTerm: Box<Term> = {
    <PathTerm> "." <Ident> => Box::new(Term::Proj(<>)),
    <ATerm>,
}

ATerm: Box<Term> = {
    Ident => Box::new(Term::Var(<>)),
    Num => Box::new(Term::Int(<>)),
    Bool => Box::new(Term::Bool(<>)),
    "(" <Term> ")",
    "{" <CommaSep<RecordField>> "}" =>
        Box::new(Term::Record(AssocList::from_vec(<>))),
    // TODO: is there a way to not have parentheses w/o shift/reduce conflicts
    "module" "ops" "type" <ty:Type> <impls:("val" <RecordField>)+> "end" "as" "(" <asc:Type> ")" =>
        Box::new(Term::Pack(ty, AssocList::from_vec(impls), asc)),
}

RecordField: (String, Box<Term>) = {
    <Ident> "=" <Term> => (<>)
}

pub TyIdent: String = {
    r"[A-Z][a-zA-Z0-9_]*" => <>.to_string()
}

pub Ident: String = {
    r"[a-z_][a-zA-Z0-9_]*" => <>.to_string()
}

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
}

Bool: bool = {
    "true" => true,
    "false" => false,
}

ArithOp: ArithOp = {
    "+" => ArithOp::Add,
    "-" => ArithOp::Sub,
    "%" => ArithOp::Mod,
    "==" => ArithOp::Eq_,
    "!=" => ArithOp::Neq,
    ">" => ArithOp::Gt,
    "<" => ArithOp::Lt,
    ">=" => ArithOp::Gte,
    "<=" => ArithOp::Lte,
}

FactorOp: ArithOp = {
    "*" => ArithOp::Mul,
    "/" => ArithOp::Div,
}

BoolOp: BoolOp = {
    "and" => BoolOp::And,
    "or" => BoolOp::Or,
}

FuncDef = {
    "lambda",
    "λ",
    "fun"
}

pub Type: Box<Type> = {
    ArrowType,
    // we assume parameters here are of kind *. would it be valid otherwise?
    Forall <p:(<TyIdent>)+> "." <ty:Type> =>
        Box::new(p
            .into_iter()
            .rev()
            .fold(*ty, |func, arg| Type::All(arg, Box::new(func)))
        ),
    "tyfun" <p:KindParams> "=>" <ty:Type> =>
        Box::new(p
            .into_iter()
            .rev()
            .fold(*ty, |func, (arg, kind)| Type::TyAbs(arg, *kind, Box::new(func)))
        ),
}

ArrowType: Box<Type> = {
    <AppType> "->" <ArrowType> => Box::new(Type::Arr(<>)),
    AppType,
}

AppType: Box<Type> = {
    AppType AType => Box::new(Type::TyApp(<>)),
    AType
}

AType: Box<Type> = {
    "(" <Type> ")",
    "{" <CommaSep<RecordFieldType>> "}" =>
        Box::new(Type::Record(AssocList::from_vec(<>))),
    "Bool" => Box::new(Type::Bool),
    "Int" => Box::new(Type::Int),
    <TyIdent> => Box::new(Type::Var(<>)),
    "module" "sig" "type" <ty:TyIdent> <sigs:("val" <RecordFieldType>)+> "end" =>
        Box::new(Type::Some(ty, AssocList::from_vec(sigs))),
}

RecordFieldType: (String, Box<Type>) = {
    <Ident> ":" <Type> => (<>)
}

KindParams: Vec<(String, Box<Kind>)> = {
    <("(" <TyIdent> ":" <Kind> ")")+>
}

pub Kind: Box<Kind> = {
    <AKind> "->" <Kind> => Box::new(Kind::Arr(<>)),
    <AKind>,
}

AKind: Box<Kind> = {
    "*" => Box::new(Kind::Proper),
    "(" <Kind> ")",
}

Forall = {
    "∀",
    "forall",
    "poly",
}

NECommaSep<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
}

CommaSep<T>: Vec<T> = {
    // lalrpop macro syntax:
    // v matches a * amount of "T," and return Vec<T>
    // e possibly matches a T, returning an Option<T>
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(field) => {
            let mut v = v;
            v.push(field);
            v
        }
    }
}
