use std::str::FromStr;
use ast::{ArithOp, BoolOp, Term};

grammar;

pub Expr: Box<Term> = {
    <Term>,
    "not" <Expr> => Box::new(Term::Not(<>)),
    "if" <Expr> "then" <Expr> "else" <Expr> => Box::new(Term::If(<>)),
    FuncDef <Ident> "." <Expr> => Box::new(Term::Abs(<>)),
    Term ArithOp Expr => Box::new(Term::Arith(<>)),
    Term BoolOp Expr => Box::new(Term::Logic(<>)),
}

Term: Box<Term> = {
    <ATerm>,
    Term ATerm => Box::new(Term::App(<>)),
    Term FactorOp ATerm => Box::new(Term::Arith(<>)),
}

ATerm: Box<Term> = {
    Ident => Box::new(Term::Var(<>)),
    Num => Box::new(Term::Int(<>)),
    Bool => Box::new(Term::Bool(<>)),
    "(" <Expr> ")",
}

Ident: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string()
}

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
}

Bool: bool = {
    "true" => true,
    "false" => false,
}

ArithOp: ArithOp = {
    "+" => ArithOp::Add,
    "-" => ArithOp::Sub,
    "%" => ArithOp::Mod,
    "=" => ArithOp::Eq_,
    "/=" => ArithOp::Neq,
    ">" => ArithOp::Gt,
    "<" => ArithOp::Lt,
    ">=" => ArithOp::Gte,
    "<=" => ArithOp::Lte,
}

FactorOp: ArithOp = {
    "*" => ArithOp::Mul,
    "/" => ArithOp::Div,
}

BoolOp: BoolOp = {
    "and" => BoolOp::And,
    "or" => BoolOp::Or,
}

FuncDef = {
    "lambda",
    "Î»",
    "fun"
}
