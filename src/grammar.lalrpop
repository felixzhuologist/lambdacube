use assoclist::{AssocList};
use syntax::{ArithOp, BoolOp, Term, Type, Command, Binder};

use std::str::FromStr;

grammar;

pub Toplevel: Vec<Command> = {
    <(<Command> ";")+>
}

pub Command: Command = {
    <Binder> => Command::Binder(<>),
    <Term> => Command::Term(<>),
}

pub Binder: Binder = {
    "let" <s:Ident> "=" <t:Term> => Binder::VarBind(s, *t),
    "let" <s:Ident> <p:Params> "=" <t:Term> => {
        let func = p.into_iter().rev().fold(*t, |func, next_param| match next_param {
            (arg, Some(ty)) => Term::Abs(arg, ty, Box::new(func)),
            (arg, None) => Term::InfAbs(arg, Box::new(func))
        });
        Binder::VarBind(s, func)
    },
    "type" <s:TyIdent> "=" <t:Type> => Binder::TyBind(s, *t),
}

pub Term: Box<Term> = {
    <AppTerm>,
    "not" <Term> => Box::new(Term::Not(<>)),
    "if" <Term> "then" <Term> "else" <Term> => Box::new(Term::If(<>)),
    "let" <Ident> "=" <Term> "in" <Term> => Box::new(Term::Let(<>)),
    FuncDef <p:Params> "->" <t:Term> => 
        Box::new(p.into_iter().rev().fold(*t, |func, next_param| match next_param {
            (arg, Some(ty)) => Term::Abs(arg, ty, Box::new(func)),
            (arg, None) => Term::InfAbs(arg, Box::new(func))
        })),
    FuncDef "[" <univ:NECommaSep<TyIdent>> "]" <p:TypedParams> "->" <body:Term> => {
        let func = p
            .into_iter()
            .rev()
            .fold(*body, |func, (arg, ty)| Term::Abs(arg, ty, Box::new(func)));

        Box::new(univ
            .into_iter()
            .rev()
            .fold(func, |func, next_| Term::TyAbs(next_, Box::new(func))))
    },
    AppTerm ArithOp Term => Box::new(Term::Arith(<>)),
    AppTerm BoolOp Term => Box::new(Term::Logic(<>)),
}

TypedParams: Vec<(String, Box<Type>)> = {
    ("(" <Ident> ":" <Type> ")")+
}

Params: Vec<(String, Option<Box<Type>>)> = {
    (<Param>)+
}

Param: (String, Option<Box<Type>>) = {
    <Ident> => (<>, None),
    "(" <s:Ident> ":" <t:Type> ")" => (s, Some(t))
}

AppTerm: Box<Term> = {
    <PathTerm>,
    AppTerm PathTerm => Box::new(Term::App(<>)),
    <univ:AppTerm> "[" <tys:NECommaSep<Type>> "]" => 
        Box::new(tys
            .into_iter()
            .rev()
            .fold(*univ, |acc, ty| Term::TyApp(Box::new(acc), ty))),
    AppTerm FactorOp PathTerm => Box::new(Term::Arith(<>)),
}

PathTerm: Box<Term> = {
    <PathTerm> "." <Ident> => Box::new(Term::Proj(<>)),
    <ATerm>,
}

ATerm: Box<Term> = {
    Ident => Box::new(Term::Var(<>)),
    Num => Box::new(Term::Int(<>)),
    Bool => Box::new(Term::Bool(<>)),
    "(" <Term> ")",
    "{" <CommaSep<RecordField>> "}" =>
        Box::new(Term::Record(AssocList::from_vec(<>))),
}

RecordField: (String, Box<Term>) = {
    <Ident> "=" <Term> => (<>)
}

TyIdent: String = {
    r"[A-Z][a-zA-Z0-9_]*" => <>.to_string()
}

Ident: String = {
    r"[a-z_][a-zA-Z0-9_]*" => <>.to_string()
}

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
}

Bool: bool = {
    "true" => true,
    "false" => false,
}

ArithOp: ArithOp = {
    "+" => ArithOp::Add,
    "-" => ArithOp::Sub,
    "%" => ArithOp::Mod,
    "==" => ArithOp::Eq_,
    "!=" => ArithOp::Neq,
    ">" => ArithOp::Gt,
    "<" => ArithOp::Lt,
    ">=" => ArithOp::Gte,
    "<=" => ArithOp::Lte,
}

FactorOp: ArithOp = {
    "*" => ArithOp::Mul,
    "/" => ArithOp::Div,
}

BoolOp: BoolOp = {
    "and" => BoolOp::And,
    "or" => BoolOp::Or,
}

FuncDef = {
    "lambda",
    "Î»",
    "fun"
}

pub Type: Box<Type> = {
    <AType>,
    <AType> "->" <Type> => Box::new(Type::Arr(<>)),
}

AType: Box<Type> = {
    "(" <Type> ")",
    "{" <CommaSep<RecordFieldType>> "}" =>
        Box::new(Type::Record(AssocList::from_vec(<>))),
    "Bool" => Box::new(Type::Bool),
    "Int" => Box::new(Type::Int),
    <TyIdent> => Box::new(Type::Var(<>)),
}

RecordFieldType: (String, Box<Type>) = {
    <Ident> ":" <Type> => (<>)
}

NECommaSep<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
}

CommaSep<T>: Vec<T> = {
    // lalrpop macro syntax:
    // v matches a * amount of "T," and return Vec<T>
    // e possibly matches a T, returning an Option<T>
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(field) => {
            let mut v = v;
            v.push(field);
            v
        }
    }
}
